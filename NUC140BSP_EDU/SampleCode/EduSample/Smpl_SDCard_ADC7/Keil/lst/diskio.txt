; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\diskio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\diskio.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\ff8\src\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC1xx\Include -I..\..\..\..\Library\Device\Nuvoton\NUC1xx\Source -I..\..\..\..\Library\ -I..\..\..\..\Library\NUC1xx\Include -I..\..\..\..\Library\NUC1xx-LB_002\Include -IF:\Keil\ARM\RV31\INC -IF:\Keil\ARM\CMSIS\Include -IF:\Keil\ARM\INC\Nuvoton\NUC1xx -D__UVISION_VERSION=524 --omf_browse=.\obj\diskio.crf ..\ff8\src\diskio.c]
                          THUMB

                          AREA ||i.RoughDelay||, CODE, READONLY, ALIGN=1

                  RoughDelay PROC
;;;19     extern int8_t Is_Initialized ;
;;;20     void RoughDelay(uint32_t t)
000000  b508              PUSH     {r3,lr}
;;;21     {
;;;22         volatile int32_t delay;
;;;23     
;;;24         delay = t;
000002  9000              STR      r0,[sp,#0]
;;;25     
;;;26         while(delay-- >= 0);
000004  bf00              NOP      
                  |L1.6|
000006  9900              LDR      r1,[sp,#0]
000008  1e4a              SUBS     r2,r1,#1
00000a  9200              STR      r2,[sp,#0]
00000c  2900              CMP      r1,#0
00000e  dafa              BGE      |L1.6|
;;;27     }
000010  bd08              POP      {r3,pc}
;;;28     
                          ENDP


                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;32     
;;;33     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;34     	BYTE drv		/* Physical drive nmuber */
;;;35     )
;;;36     {
000002  4605              MOV      r5,r0
;;;37     	DSTATUS sta;
;;;38     	GPIOD->PMD.PMD12=1;
000004  4814              LDR      r0,|L2.88|
000006  6800              LDR      r0,[r0,#0]
000008  2103              MOVS     r1,#3
00000a  0609              LSLS     r1,r1,#24
00000c  4388              BICS     r0,r0,r1
00000e  2101              MOVS     r1,#1
000010  0609              LSLS     r1,r1,#24
000012  1840              ADDS     r0,r0,r1
000014  4910              LDR      r1,|L2.88|
000016  6008              STR      r0,[r1,#0]
;;;39     	GPIOD->DOUT&=0xEFFF;
000018  4608              MOV      r0,r1
00001a  6880              LDR      r0,[r0,#8]
00001c  490f              LDR      r1,|L2.92|
00001e  4008              ANDS     r0,r0,r1
000020  490d              LDR      r1,|L2.88|
000022  6088              STR      r0,[r1,#8]
;;;40     
;;;41     	while((GPIOD->PIN&0x2000)!=0);
000024  bf00              NOP      
                  |L2.38|
000026  480c              LDR      r0,|L2.88|
000028  6900              LDR      r0,[r0,#0x10]
00002a  2101              MOVS     r1,#1
00002c  0349              LSLS     r1,r1,#13
00002e  4008              ANDS     r0,r0,r1
000030  2800              CMP      r0,#0
000032  d1f8              BNE      |L2.38|
;;;42     	RoughDelay(100000);
000034  480a              LDR      r0,|L2.96|
000036  f7fffffe          BL       RoughDelay
;;;43     	if(DrvSDCARD_Open() == E_SUCCESS)
00003a  f7fffffe          BL       DrvSDCARD_Open
00003e  2800              CMP      r0,#0
000040  d104              BNE      |L2.76|
;;;44     	{	
;;;45     	sta = 	RES_OK;
000042  2400              MOVS     r4,#0
;;;46     		printf("SDCard Open success\n");
000044  a007              ADR      r0,|L2.100|
000046  f7fffffe          BL       __2printf
00004a  e003              B        |L2.84|
                  |L2.76|
;;;47     
;;;48     	}
;;;49     	else
;;;50     	{
;;;51     	sta = STA_NOINIT;
00004c  2401              MOVS     r4,#1
;;;52     		printf("SDCard Open failed\n");
00004e  a00b              ADR      r0,|L2.124|
000050  f7fffffe          BL       __2printf
                  |L2.84|
;;;53     	}
;;;54     	return sta;
000054  4620              MOV      r0,r4
;;;55     
;;;56     }
000056  bd70              POP      {r4-r6,pc}
;;;57     
                          ENDP

                  |L2.88|
                          DCD      0x500040c0
                  |L2.92|
                          DCD      0x0000efff
                  |L2.96|
                          DCD      0x000186a0
                  |L2.100|
000064  53444361          DCB      "SDCard Open success\n",0
000068  7264204f
00006c  70656e20
000070  73756363
000074  6573730a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L2.124|
00007c  53444361          DCB      "SDCard Open failed\n",0
000080  7264204f
000084  70656e20
000088  6661696c
00008c  65640a00

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;154    
;;;155    DRESULT disk_ioctl (
000000  b5f8              PUSH     {r3-r7,lr}
;;;156    	BYTE drv,		/* Physical drive nmuber (0) */
;;;157    	BYTE ctrl,		/* Control code */
;;;158    	void *buff		/* Buffer to send/receive data block */
;;;159    )
;;;160    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
;;;161    	DRESULT res;
;;;162    
;;;163    //	BYTE n;
;;;164    
;;;165    	if (drv) return RES_PARERR;
000008  2e00              CMP      r6,#0
00000a  d001              BEQ      |L3.16|
00000c  2004              MOVS     r0,#4
                  |L3.14|
;;;166    
;;;167    	switch (ctrl) {
;;;168    	case CTRL_SYNC :		/* Make sure that no pending write process */
;;;169    		res = RES_OK;
;;;170    		break;
;;;171    
;;;172    	case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;;;173    		DrvSDCARD_GetCardSize(buff);
;;;174    		res = RES_OK;
;;;175    		break;
;;;176    
;;;177    	case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
;;;178    		*(DWORD*)buff = 512;	//512;
;;;179    		res = RES_OK;
;;;180    		break;
;;;181    
;;;182    	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;;;183    		*(DWORD*)buff = 1;
;;;184    		res = RES_OK;
;;;185    		break;
;;;186    
;;;187    
;;;188    	default:
;;;189    		res = RES_PARERR;
;;;190    	}
;;;191    
;;;192    
;;;193    	res = RES_OK;
;;;194    
;;;195    
;;;196    	return res;
;;;197    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L3.16|
000010  2f00              CMP      r7,#0                 ;167
000012  d006              BEQ      |L3.34|
000014  2f01              CMP      r7,#1                 ;167
000016  d006              BEQ      |L3.38|
000018  2f02              CMP      r7,#2                 ;167
00001a  d009              BEQ      |L3.48|
00001c  2f03              CMP      r7,#3                 ;167
00001e  d110              BNE      |L3.66|
000020  e00b              B        |L3.58|
                  |L3.34|
000022  2400              MOVS     r4,#0                 ;169
000024  e00f              B        |L3.70|
                  |L3.38|
000026  4628              MOV      r0,r5                 ;173
000028  f7fffffe          BL       DrvSDCARD_GetCardSize
00002c  2400              MOVS     r4,#0                 ;174
00002e  e00a              B        |L3.70|
                  |L3.48|
000030  2001              MOVS     r0,#1                 ;178
000032  0240              LSLS     r0,r0,#9              ;178
000034  6028              STR      r0,[r5,#0]            ;178
000036  2400              MOVS     r4,#0                 ;179
000038  e005              B        |L3.70|
                  |L3.58|
00003a  2001              MOVS     r0,#1                 ;183
00003c  6028              STR      r0,[r5,#0]            ;183
00003e  2400              MOVS     r4,#0                 ;184
000040  e001              B        |L3.70|
                  |L3.66|
000042  2404              MOVS     r4,#4                 ;189
000044  bf00              NOP                            ;167
                  |L3.70|
000046  bf00              NOP                            ;170
000048  2400              MOVS     r4,#0                 ;193
00004a  4620              MOV      r0,r4                 ;196
00004c  e7df              B        |L3.14|
;;;198    
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;81     
;;;82     DRESULT disk_read (
000000  b5ff              PUSH     {r0-r7,lr}
;;;83     	BYTE drv,			/* Physical drive nmuber (0) */
;;;84     	BYTE *buff,			/* Pointer to the data buffer to store read data */
;;;85     	DWORD sector,		/* Start sector number (LBA) */
;;;86     	BYTE count			/* Sector count (1..255) */
;;;87     )
;;;88     {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  461c              MOV      r4,r3
;;;89     	DRESULT res;
;;;90     	uint32_t size;
;;;91     	  	if (drv) {
00000a  2e00              CMP      r6,#0
00000c  d003              BEQ      |L4.22|
;;;92     			res = (DRESULT)STA_NOINIT;	
00000e  2501              MOVS     r5,#1
;;;93     		return res;
000010  4628              MOV      r0,r5
                  |L4.18|
;;;94     		}
;;;95     
;;;96     
;;;97          if(count==0||count>=2)
;;;98     	   	{	 
;;;99     		res =   (DRESULT)STA_NOINIT;
;;;100    		return res;
;;;101    	}
;;;102    
;;;103    	    size=count*512;
;;;104    		SpiRead(sector, size, buff);			
;;;105    		res =RES_OK;	/* Clear STA_NOINIT */;
;;;106    
;;;107    	return res;
;;;108    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L4.22|
000016  2c00              CMP      r4,#0                 ;97
000018  d001              BEQ      |L4.30|
00001a  2c02              CMP      r4,#2                 ;97
00001c  db02              BLT      |L4.36|
                  |L4.30|
00001e  2501              MOVS     r5,#1                 ;99
000020  4628              MOV      r0,r5                 ;100
000022  e7f6              B        |L4.18|
                  |L4.36|
000024  0260              LSLS     r0,r4,#9              ;103
000026  9000              STR      r0,[sp,#0]            ;103
000028  463a              MOV      r2,r7                 ;104
00002a  9900              LDR      r1,[sp,#0]            ;104
00002c  9803              LDR      r0,[sp,#0xc]          ;104
00002e  f7fffffe          BL       SpiRead
000032  2500              MOVS     r5,#0                 ;105
000034  4628              MOV      r0,r5                 ;107
000036  e7ec              B        |L4.18|
;;;109    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;63     
;;;64     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;65     	BYTE drv		/* Physical drive nmuber (0) */
;;;66     )
;;;67     {   
;;;68     	DSTATUS sta1=STA_OK;
000002  2000              MOVS     r0,#0
;;;69     	if (drv) 
000004  2900              CMP      r1,#0
000006  d000              BEQ      |L5.10|
;;;70     		sta1 =   STA_NOINIT;
000008  2001              MOVS     r0,#1
                  |L5.10|
;;;71     	return sta1;
;;;72     }
00000a  4770              BX       lr
;;;73     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;116    #if _READONLY == 0
;;;117    DRESULT disk_write (
000000  b5ff              PUSH     {r0-r7,lr}
;;;118    	BYTE drv,			/* Physical drive nmuber (0) */
;;;119    	const BYTE *buff,	/* Pointer to the data to be written */
;;;120    	DWORD sector,		/* Start sector number (LBA) */
;;;121    	BYTE count			/* Sector count (1..255) */
;;;122    )
;;;123    {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  461c              MOV      r4,r3
;;;124    
;;;125    	DRESULT  res;	
;;;126        uint32_t size;
;;;127    
;;;128    
;;;129     	if (drv) {
00000a  2e00              CMP      r6,#0
00000c  d003              BEQ      |L6.22|
;;;130    		res = (DRESULT)STA_NOINIT;	
00000e  2501              MOVS     r5,#1
;;;131    		return res;
000010  4628              MOV      r0,r5
                  |L6.18|
;;;132    	}
;;;133    
;;;134    
;;;135    	     
;;;136        if(count==0||count>=2)
;;;137    	{	 
;;;138    		res = (DRESULT)  STA_NOINIT;
;;;139    		return res;
;;;140    	}
;;;141    	    size=count*512;
;;;142    		SpiWrite(sector, size,(uint8_t *)buff);
;;;143    	    res = RES_OK;
;;;144    
;;;145    	return res;
;;;146    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L6.22|
000016  2c00              CMP      r4,#0                 ;136
000018  d001              BEQ      |L6.30|
00001a  2c02              CMP      r4,#2                 ;136
00001c  db02              BLT      |L6.36|
                  |L6.30|
00001e  2501              MOVS     r5,#1                 ;138
000020  4628              MOV      r0,r5                 ;139
000022  e7f6              B        |L6.18|
                  |L6.36|
000024  0260              LSLS     r0,r4,#9              ;141
000026  9000              STR      r0,[sp,#0]            ;141
000028  463a              MOV      r2,r7                 ;142
00002a  9900              LDR      r1,[sp,#0]            ;142
00002c  9803              LDR      r0,[sp,#0xc]          ;142
00002e  f7fffffe          BL       SpiWrite
000032  2500              MOVS     r5,#0                 ;143
000034  4628              MOV      r0,r5                 ;145
000036  e7ec              B        |L6.18|
;;;147    #endif /* _READONLY */
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Storage_Block
                          %        1024
