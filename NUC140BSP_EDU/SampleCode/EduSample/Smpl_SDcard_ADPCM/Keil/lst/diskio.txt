; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\diskio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\diskio.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\ff8\src\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC1xx\Include -I..\..\..\..\Library\Device\Nuvoton\NUC1xx\Source -I..\..\..\..\Library\ -I..\..\..\..\Library\NUC1xx\Include -I..\..\..\..\Library\NUC1xx-LB_002\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Nuvoton\NUC1xx -D__UVISION_VERSION=524 --omf_browse=.\obj\diskio.crf ..\ff8\src\diskio.c]
                          THUMB

                          AREA ||i.RoughDelay||, CODE, READONLY, ALIGN=1

                  RoughDelay PROC
;;;16     extern int8_t Is_Initialized ;
;;;17     void RoughDelay(uint32_t t)
000000  b508              PUSH     {r3,lr}
;;;18     {
;;;19         volatile int32_t delay;
;;;20     
;;;21         delay = t;
000002  9000              STR      r0,[sp,#0]
;;;22     
;;;23         while(delay-- >= 0);
000004  bf00              NOP      
                  |L1.6|
000006  9900              LDR      r1,[sp,#0]
000008  1e4a              SUBS     r2,r1,#1
00000a  9200              STR      r2,[sp,#0]
00000c  2900              CMP      r1,#0
00000e  dafa              BGE      |L1.6|
;;;24     }
000010  bd08              POP      {r3,pc}
;;;25     
                          ENDP


                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;29     
;;;30     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;31     	BYTE drv		/* Physical drive nmuber */
;;;32     )
;;;33     {
000002  4605              MOV      r5,r0
;;;34     	DSTATUS sta;
;;;35     	GPIOD->PMD.PMD12=1;
000004  4814              LDR      r0,|L2.88|
000006  6800              LDR      r0,[r0,#0]
000008  2103              MOVS     r1,#3
00000a  0609              LSLS     r1,r1,#24
00000c  4388              BICS     r0,r0,r1
00000e  2101              MOVS     r1,#1
000010  0609              LSLS     r1,r1,#24
000012  1840              ADDS     r0,r0,r1
000014  4910              LDR      r1,|L2.88|
000016  6008              STR      r0,[r1,#0]
;;;36     	GPIOD->DOUT&=0xEFFF;
000018  4608              MOV      r0,r1
00001a  6880              LDR      r0,[r0,#8]
00001c  490f              LDR      r1,|L2.92|
00001e  4008              ANDS     r0,r0,r1
000020  490d              LDR      r1,|L2.88|
000022  6088              STR      r0,[r1,#8]
;;;37     
;;;38     	while((GPIOD->PIN&0x2000)!=0);
000024  bf00              NOP      
                  |L2.38|
000026  480c              LDR      r0,|L2.88|
000028  6900              LDR      r0,[r0,#0x10]
00002a  2101              MOVS     r1,#1
00002c  0349              LSLS     r1,r1,#13
00002e  4008              ANDS     r0,r0,r1
000030  2800              CMP      r0,#0
000032  d1f8              BNE      |L2.38|
;;;39     	RoughDelay(100000);
000034  480a              LDR      r0,|L2.96|
000036  f7fffffe          BL       RoughDelay
;;;40     	if(DrvSDCARD_Open() == E_SUCCESS)
00003a  f7fffffe          BL       DrvSDCARD_Open
00003e  2800              CMP      r0,#0
000040  d104              BNE      |L2.76|
;;;41     	{	
;;;42     	sta = 	RES_OK;
000042  2400              MOVS     r4,#0
;;;43     		printf("SDCard Open success\n");
000044  a007              ADR      r0,|L2.100|
000046  f7fffffe          BL       __2printf
00004a  e003              B        |L2.84|
                  |L2.76|
;;;44     	}
;;;45     	else
;;;46     	{
;;;47     	sta = STA_NOINIT;
00004c  2401              MOVS     r4,#1
;;;48     		printf("SDCard Open failed\n");
00004e  a00b              ADR      r0,|L2.124|
000050  f7fffffe          BL       __2printf
                  |L2.84|
;;;49     	}
;;;50     	return sta;
000054  4620              MOV      r0,r4
;;;51     
;;;52     }
000056  bd70              POP      {r4-r6,pc}
;;;53     
                          ENDP

                  |L2.88|
                          DCD      0x500040c0
                  |L2.92|
                          DCD      0x0000efff
                  |L2.96|
                          DCD      0x000186a0
                  |L2.100|
000064  53444361          DCB      "SDCard Open success\n",0
000068  7264204f
00006c  70656e20
000070  73756363
000074  6573730a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L2.124|
00007c  53444361          DCB      "SDCard Open failed\n",0
000080  7264204f
000084  70656e20
000088  6661696c
00008c  65640a00

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;150    
;;;151    DRESULT disk_ioctl (
000000  b5f8              PUSH     {r3-r7,lr}
;;;152    	BYTE drv,		/* Physical drive nmuber (0) */
;;;153    	BYTE ctrl,		/* Control code */
;;;154    	void *buff		/* Buffer to send/receive data block */
;;;155    )
;;;156    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
;;;157    	DRESULT res;
;;;158    
;;;159    //	BYTE n;
;;;160    
;;;161    	if (drv) return RES_PARERR;
000008  2e00              CMP      r6,#0
00000a  d001              BEQ      |L3.16|
00000c  2004              MOVS     r0,#4
                  |L3.14|
;;;162    
;;;163    	switch (ctrl) {
;;;164    	case CTRL_SYNC :		/* Make sure that no pending write process */
;;;165    		res = RES_OK;
;;;166    		break;
;;;167    
;;;168    	case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;;;169    		DrvSDCARD_GetCardSize(buff);
;;;170    		res = RES_OK;
;;;171    		break;
;;;172    
;;;173    	case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
;;;174    		*(DWORD*)buff = 512;	//512;
;;;175    		res = RES_OK;
;;;176    		break;
;;;177    
;;;178    	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;;;179    		*(DWORD*)buff = 1;
;;;180    		res = RES_OK;
;;;181    		break;
;;;182    
;;;183    
;;;184    	default:
;;;185    		res = RES_PARERR;
;;;186    	}
;;;187    
;;;188    
;;;189    	res = RES_OK;
;;;190    
;;;191    
;;;192    	return res;
;;;193    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L3.16|
000010  2f00              CMP      r7,#0                 ;163
000012  d006              BEQ      |L3.34|
000014  2f01              CMP      r7,#1                 ;163
000016  d006              BEQ      |L3.38|
000018  2f02              CMP      r7,#2                 ;163
00001a  d009              BEQ      |L3.48|
00001c  2f03              CMP      r7,#3                 ;163
00001e  d110              BNE      |L3.66|
000020  e00b              B        |L3.58|
                  |L3.34|
000022  2400              MOVS     r4,#0                 ;165
000024  e00f              B        |L3.70|
                  |L3.38|
000026  4628              MOV      r0,r5                 ;169
000028  f7fffffe          BL       DrvSDCARD_GetCardSize
00002c  2400              MOVS     r4,#0                 ;170
00002e  e00a              B        |L3.70|
                  |L3.48|
000030  2001              MOVS     r0,#1                 ;174
000032  0240              LSLS     r0,r0,#9              ;174
000034  6028              STR      r0,[r5,#0]            ;174
000036  2400              MOVS     r4,#0                 ;175
000038  e005              B        |L3.70|
                  |L3.58|
00003a  2001              MOVS     r0,#1                 ;179
00003c  6028              STR      r0,[r5,#0]            ;179
00003e  2400              MOVS     r4,#0                 ;180
000040  e001              B        |L3.70|
                  |L3.66|
000042  2404              MOVS     r4,#4                 ;185
000044  bf00              NOP                            ;163
                  |L3.70|
000046  bf00              NOP                            ;166
000048  2400              MOVS     r4,#0                 ;189
00004a  4620              MOV      r0,r4                 ;192
00004c  e7df              B        |L3.14|
;;;194    
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;77     
;;;78     DRESULT disk_read (
000000  b5ff              PUSH     {r0-r7,lr}
;;;79     	BYTE drv,			/* Physical drive nmuber (0) */
;;;80     	BYTE *buff,			/* Pointer to the data buffer to store read data */
;;;81     	DWORD sector,		/* Start sector number (LBA) */
;;;82     	BYTE count			/* Sector count (1..255) */
;;;83     )
;;;84     {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  461c              MOV      r4,r3
;;;85     	DRESULT res;
;;;86     	uint32_t size;
;;;87     	  	if (drv) {
00000a  2e00              CMP      r6,#0
00000c  d003              BEQ      |L4.22|
;;;88     			res = (DRESULT)STA_NOINIT;	
00000e  2501              MOVS     r5,#1
;;;89     		return res;
000010  4628              MOV      r0,r5
                  |L4.18|
;;;90     		}
;;;91     
;;;92     
;;;93          if(count==0||count>=2)
;;;94     	   	{	 
;;;95     		res =   (DRESULT)STA_NOINIT;
;;;96     		return res;
;;;97     	}
;;;98     
;;;99     	    size=count*512;
;;;100    		SpiRead(sector, size, buff);			
;;;101    		res =RES_OK;	/* Clear STA_NOINIT */;
;;;102    
;;;103    	return res;
;;;104    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L4.22|
000016  2c00              CMP      r4,#0                 ;93
000018  d001              BEQ      |L4.30|
00001a  2c02              CMP      r4,#2                 ;93
00001c  db02              BLT      |L4.36|
                  |L4.30|
00001e  2501              MOVS     r5,#1                 ;95
000020  4628              MOV      r0,r5                 ;96
000022  e7f6              B        |L4.18|
                  |L4.36|
000024  0260              LSLS     r0,r4,#9              ;99
000026  9000              STR      r0,[sp,#0]            ;99
000028  463a              MOV      r2,r7                 ;100
00002a  9900              LDR      r1,[sp,#0]            ;100
00002c  9803              LDR      r0,[sp,#0xc]          ;100
00002e  f7fffffe          BL       SpiRead
000032  2500              MOVS     r5,#0                 ;101
000034  4628              MOV      r0,r5                 ;103
000036  e7ec              B        |L4.18|
;;;105    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;59     
;;;60     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;61     	BYTE drv		/* Physical drive nmuber (0) */
;;;62     )
;;;63     {   
;;;64     	DSTATUS sta1=STA_OK;
000002  2000              MOVS     r0,#0
;;;65     	if (drv) 
000004  2900              CMP      r1,#0
000006  d000              BEQ      |L5.10|
;;;66     		sta1 =   STA_NOINIT;
000008  2001              MOVS     r0,#1
                  |L5.10|
;;;67     	return sta1;
;;;68     }
00000a  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;112    #if _READONLY == 0
;;;113    DRESULT disk_write (
000000  b5ff              PUSH     {r0-r7,lr}
;;;114    	BYTE drv,			/* Physical drive nmuber (0) */
;;;115    	const BYTE *buff,	/* Pointer to the data to be written */
;;;116    	DWORD sector,		/* Start sector number (LBA) */
;;;117    	BYTE count			/* Sector count (1..255) */
;;;118    )
;;;119    {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  461c              MOV      r4,r3
;;;120    
;;;121    	DRESULT  res;	
;;;122        uint32_t size;
;;;123    
;;;124    
;;;125     	if (drv) {
00000a  2e00              CMP      r6,#0
00000c  d003              BEQ      |L6.22|
;;;126    		res = (DRESULT)STA_NOINIT;	
00000e  2501              MOVS     r5,#1
;;;127    		return res;
000010  4628              MOV      r0,r5
                  |L6.18|
;;;128    	}
;;;129    
;;;130    
;;;131    	     
;;;132        if(count==0||count>=2)
;;;133    	{	 
;;;134    		res = (DRESULT)  STA_NOINIT;
;;;135    		return res;
;;;136    	}
;;;137    	    size=count*512;
;;;138    		SpiWrite(sector, size,(uint8_t *)buff);
;;;139    	    res = RES_OK;
;;;140    
;;;141    	return res;
;;;142    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L6.22|
000016  2c00              CMP      r4,#0                 ;132
000018  d001              BEQ      |L6.30|
00001a  2c02              CMP      r4,#2                 ;132
00001c  db02              BLT      |L6.36|
                  |L6.30|
00001e  2501              MOVS     r5,#1                 ;134
000020  4628              MOV      r0,r5                 ;135
000022  e7f6              B        |L6.18|
                  |L6.36|
000024  0260              LSLS     r0,r4,#9              ;137
000026  9000              STR      r0,[sp,#0]            ;137
000028  463a              MOV      r2,r7                 ;138
00002a  9900              LDR      r1,[sp,#0]            ;138
00002c  9803              LDR      r0,[sp,#0xc]          ;138
00002e  f7fffffe          BL       SpiWrite
000032  2500              MOVS     r5,#0                 ;139
000034  4628              MOV      r0,r5                 ;141
000036  e7ec              B        |L6.18|
;;;143    #endif /* _READONLY */
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;202    
;;;203    unsigned long get_fattime (void)
000000  2000              MOVS     r0,#0
;;;204    {
;;;205    	unsigned long tmr;
;;;206    
;;;207        tmr=0x00000;
;;;208    
;;;209    	return tmr;
;;;210    }
000002  4770              BX       lr
;;;211    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Storage_Block
                          %        1024
